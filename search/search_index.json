{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cheshire","text":"<p>Cheshire is a minimal Linux-capable host platform built around the RISC-V CVA6 core. Its goal is to provide a lightweight, configurable, autonomously booting host to systems that need one, from minimal Linux-capable SoCs to manycore compute accelerators.</p> <p>Cheshire is developed as part of the PULP project, a joint effort between ETH Zurich and the University of Bologna.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>To learn how to build and use Cheshire, see Getting Started.</li> <li>To learn about available simulation, FPGA, and ASIC targets, see Targets.</li> <li>For detailed information on Cheshire's inner workings, consult the User Manual.</li> </ul> <p>If you are impatient and have all needed dependencies, you can run <code>make all</code>, then start QuestaSim in <code>target/sim/vsim</code> and run a simulation by typing:</p> <pre><code>set BINARY ../../../sw/tests/helloworld.spm.elf\nsource compile.tcl\nsource start.cheshire_soc.tcl\nrun -all\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Unless specified otherwise in the respective file headers, all code checked into this repository is made available under a permissive license. All hardware sources and tool scripts are licensed under the Solderpad Hardware License 0.51 (see <code>LICENSE</code>) with the exception of generated register file code (e.g. <code>hw/regs/*.sv</code>), which is generated by a fork of lowRISC's <code>regtool</code> and licensed under Apache 2.0. All software sources are licensed under Apache 2.0.</p>"},{"location":"#publication","title":"Publication","text":"<p>If you use Cheshire in your work, you can cite us:</p> <pre><code>@article{ottaviano2023cheshire,\n      title   = {Cheshire: A Lightweight, Linux-Capable RISC-V Host\n                 Platform for Domain-Specific Accelerator Plug-In},\n      author  = {Alessandro Ottaviano and Thomas Benz and\n                 Paul Scheffler and Luca Benini},\n      journal = {IEEE Transactions on Circuits and Systems II: Express Briefs},\n      year    = {2023},\n      volume  = {70},\n      number  = {10},\n      pages   = {3777-3781},\n      doi     = {10.1109/TCSII.2023.3289186}\n}\n</code></pre>"},{"location":"gs/","title":"Getting Started","text":"<p>We first discuss the Cheshire's project structure, its dependencies, and how to build it.</p>"},{"location":"gs/#repository-structure","title":"Repository structure","text":"<p>The project is structured as follows:</p> Directory Description Documentation <code>hw</code> Hardware sources as SystemVerilog RTL Architecture <code>sw</code> Software stack, build setup, and tests Software Stack <code>target</code> Simulation, FPGA, and ASIC target setups Targets <code>util</code> Utility scripts <code>doc</code> Documentation Home"},{"location":"gs/#dependencies","title":"Dependencies","text":"<p>To build Cheshire, you will need:</p> <ul> <li>GNU Make <code>&gt;= 3.82</code></li> <li>Python <code>&gt;= 3.9</code></li> <li>Bender <code>&gt;= 0.27.1</code></li> <li>RISCV GCC <code>&gt;= 11.2.0</code></li> <li>Python packages in <code>requirements.txt</code></li> </ul> <p>We use Bender for hardware IP and dependency management; for more information on using Bender, please see its documentation. You can install Bender directly through the Rust package manager Cargo:</p> <pre><code>cargo install bender\n</code></pre> <p>Depending on your desired target, additional dependencies may be needed.</p>"},{"location":"gs/#building-cheshire","title":"Building Cheshire","text":"<p>To build different parts of Cheshire, run <code>make</code> followed by these targets:</p> <ul> <li><code>hw-all</code>: generated hardware, including IPs and boot ROM</li> <li><code>sw-all</code>: software running on our hardware</li> <li><code>sim-all</code>(\u2020): scripts and external models for simulation</li> <li><code>xilinx-all</code>: scripts for Xilinx FPGA implementation</li> </ul> <p>\u2020 <code>sim-all</code> will download externally provided peripheral simulation models, some proprietary and with non-free license terms, from their publically accessible sources; see <code>Makefile</code> for details. By running <code>sim-all</code> or the default target <code>all</code>, you accept this.</p> <p>Running <code>hw-all</code> is required at least once to correctly configure IPs we depend on. On reconfiguring any generated hardware or changing IP versions, <code>hw-all</code> should be rerun.</p> <p>To run all build targets above (\u2020):</p> <pre><code>make all\n</code></pre> <p>The following additional targets are not invoked by the above, but also available:</p> <ul> <li><code>bootrom-all</code>: Rebuilds the boot ROM. This is not done by default as reproducible builds (as checked by CI) can only be guaranteed for fixed compiler versions.</li> <li><code>nonfree-init</code>: Clones our internal repository with nonfree resources we cannot release, including our internal CI. This is not necessary to use Cheshire.</li> <li><code>clean-deps</code>: Removes checked-out bender dependencies and submodules. This is useful when references to dependencies are updated.</li> </ul>"},{"location":"gs/#targets","title":"Targets","text":"<p>A target is an end use for Cheshire. Each target requires different steps from here; read the page for your desired target in the following Targets chapter.</p>"},{"location":"tg/","title":"Targets","text":"<p>A target refers to an end use of Cheshire. This could be a simulation setup, an FPGA or ASIC implementation, or the integration into other SoCs.</p> <p>Target setups can either be included in this repository or live in an external repository and use Cheshire as a dependency.</p>"},{"location":"tg/#included-targets","title":"Included Targets","text":"<p>Included target setups live in the <code>target</code> directory. The associated make targets <code>&lt;target&gt;-all</code>  set up necessary resources and scripts before use.</p> <p>Each included target has a documentation page in this chapter:</p> <ul> <li>Simulation</li> <li>Xilinx FPGAs</li> </ul>"},{"location":"tg/#external-targets","title":"External Targets","text":"<p>For integration into other SoCs, Cheshire may be included either as a Bender dependency or Git submodule. For further information and best pratices, see SoC Integration.</p>"},{"location":"tg/integr/","title":"SoC Integration","text":"<p>Cheshire is designed to be highly configurable and provide host and interconnect infrastructure for systems on various scales. Examples of SoCs integrating Cheshire as a host are:</p> <ul> <li>Iguana, an minimal end-to-end open-source Linux-capable SoC built with open tools.</li> <li>Carfield, a mixed-criticality SoC targeting the automotive domain.</li> </ul>"},{"location":"tg/integr/#using-cheshire-in-your-project","title":"Using Cheshire In Your Project","text":"<p>As for internal targets, Cheshire must be built before use in external projects. We aim to simplify this as much as possible with a portable make fragment.</p> <p>If you use GNU Make to build your project and Bender to handle dependencies, you can include the Cheshire build system into your own makefile with:</p> <pre><code>include $(shell bender path cheshire)/cheshire.mk\n</code></pre> <p>All of Cheshire's build targets are now available with the prefix <code>chs-</code>. Alternatively, the variables <code>CHS_*</code> provide the non-phony targets built by each of these targets.</p> <p>You can leverage this to ensure your Cheshire build is up to date and rebuild hardware and software whenever necessary. You can change the default value of any build parameter, replace source files to adapt Cheshire, or reuse parts of its build system, such as the software stack or the register and ROM generators.</p>"},{"location":"tg/integr/#instantiating-cheshire","title":"Instantiating Cheshire","text":"<p>Almost all features of Cheshire can be included, excluded, or scaled through parameterization. We impose an internal memory map and reasonable constraints on all parameters, but within these constraints, Cheshire can scale to fit numerous scenarios.</p> <p>We provide a SystemVerilog macros header in <code>hw/include/cheshire/typedef.svh</code> that simplifies defining necessary interface types for Cheshire. To define a configuration struct for Cheshire, we recommend defining a function in a system package that starts from the default configuration <code>DefaultCfg</code> in <code>cheshire_pkg</code> and changes only necessary parameters.</p> <p>Unused inputs and inputs of zero effective width should be tied so as to not initiate data transfers or handshakes (usually <code>'0</code>).</p> <p>A minimal clean instantiation would look as follows:</p> <pre><code>`include \"cheshire/typedef.svh\"\n\n// Define function to derive configuration from defaults.\n// This could also (preferrably) be done in a system package.\nfunction automatic cheshire_pkg::cheshire_cfg_t gen_cheshire_cfg();\n  cheshire_pkg::cheshire_cfg_t ret = cheshire_pkg::DefaultCfg;\n  // Make overriding changes. Here, we add two AXI manager ports\n  ret.AxiExtNumMst = 2;\n  return ret;\nendfunction\n\nlocalparam cheshire_cfg_t CheshireCfg = gen_cheshire_cfg();\n\n// Generate interface types prefixed by `csh_` from our configuration.\n`CHESHIRE_TYPEDEF_ALL(csh_, CheshireCfg)\n\n// Instantiate Cheshire with our configuration and interface types.\ncheshire_soc #(\n  .Cfg                ( CheshireCfg ),\n  .ExtHartinfo        ( '0 ), // Tie iff there are no external harts.\n  .axi_ext_llc_req_t  ( csh_axi_llc_req_t ),\n  .axi_ext_llc_rsp_t  ( csh_axi_llc_rsp_t ),\n  .axi_ext_mst_req_t  ( csh_axi_mst_req_t ),\n  .axi_ext_mst_rsp_t  ( csh_axi_mst_rsp_t ),\n  .axi_ext_slv_req_t  ( csh_axi_slv_req_t ),\n  .axi_ext_slv_rsp_t  ( csh_axi_slv_rsp_t ),\n  .reg_ext_req_t      ( csh_reg_req_t ),\n  .reg_ext_rsp_t      ( csh_reg_rsp_t )\n) dut (\n  // ... IOs here ...\n);\n</code></pre>"},{"location":"tg/integr/#verifying-cheshire-in-system","title":"Verifying Cheshire In-System","text":"<p>To simplify the simulation and verification of Cheshire in other systems, we provide a monolithic block of verification IPs called <code>cheshire_vip</code>. This includes:</p> <ul> <li>ELF binary preloading tasks over JTAG, serial link, and UART.</li> <li>External AXI manager ports accessing the chip through the serial link.</li> <li>A UART receiver printing to standard output.</li> <li>Serial link and LLC subordinate memories.</li> <li>Preloadable I2C EEPROM and SPI NOR Flash models (used to simulate boot).</li> </ul> <p>Additionally, we provide a module <code>cheshire_vip_tristate</code> which adapts the unidirectional IO of this module to bidirectional IOs which may be interfaced with pads where necessary.</p>"},{"location":"tg/integr/#platform-rom","title":"Platform ROM","text":"<p>To set up boot-critical resources in the surrounding system (clock sources, IO pads, memories, PHYs, ...) or fork off execution from the built-in boot ROM, Cheshire can invoke an external platform ROM before external interaction if configured accordingly; see Boot ROM.</p> <p>Note that a reference clock, a sufficiently fast and stable system clock, correctly set-up IOs, and an accessible scratchpad memory are required for Cheshire's built-in boot modes. Platforms which do not inherently fulfill these criteria on boot ROM entry and want to use the built-in boot methods must provide a platform ROM.</p> <p>The platform ROM can be also used to extend and customize the boot chain. This may include adding further boot modes, suspending Cheshire boot until a given time, or implementing security features.</p>"},{"location":"tg/sim/","title":"Simulation","text":"<p>This page describes how to simulate Cheshire to execute baremetal programs. Please first read Getting Started to make sure to make sure have all dependencies and built the hardware, software, and simulation scripts.</p> <p>We currently provide working setups for:</p> <ul> <li>Questa Advanced Simulator (QuestaSim) <code>&gt;= 2022.3</code></li> </ul> <p>We plan on supporting more simulators in the future. If your situation requires it, simulating Cheshire on other setups should be straightforward.</p>"},{"location":"tg/sim/#testbench","title":"Testbench","text":"<p>We provide a SystemVerilog testbench for <code>cheshire_soc</code> running baremetal programs. This code is either preloaded through simulated interface drivers or read from external memory models by the boot ROM and then executed, depending on how the  <code>PRELMODE</code> and <code>BOOTMODE</code> variables are set:</p> <code>BOOTMODE</code> <code>PRELMODE</code> Action 0 0 Preload through JTAG 0 1 Preload through serial link 0 2 Preload through UART 1-3 - Autonomous boot, see Boot ROM <p>Preloading boot modes expect an ELF executable to be passed through <code>BINARY</code>, while autonomous boot modes expect a disk image (GPT formatted or raw code) to be passed through <code>IMAGE</code>. For more information on how to build software for Cheshire and its boot process, see Software Stack.</p> <p>The <code>SELCFG</code> parameter selects the simulation configuration specified in the <code>tb_cheshire_pkg</code> package. If not set or set to <code>0</code>, the default configuration is selected.</p> <code>SELCFG</code> Configuration (<code>tb_cheshire_pkg</code>) 0 Default configuration from <code>cheshire_pkg</code> 1 AXI-RT-enabled configuration <p>For simulation of Cheshire in other designs, we provide the module <code>cheshire_vip</code> encapsulating all verification IPs and their interfaces. For details, see Verifying Cheshire In-System.</p>"},{"location":"tg/sim/#questasim","title":"QuestaSim","text":"<p>After building Cheshire, start QuestaSim in <code>target/sim/vsim</code> and run:</p> <pre><code># Preload `helloworld.spm.elf` through serial link\nset BINARY ../../../sw/tests/helloworld.spm.elf\nset BOOTMODE 0\nset PRELMODE 1\n\n# Compile design\nsource compile.tcl\n\n# Start and run simulation\nsource start.cheshire_soc.tcl\nrun -all\n</code></pre> <p>The design needs to be recompiled only when hardware is changed. The simulation can be restarted by re-sourcing <code>start.cheshire_soc.tcl</code>, allowing binary (or image) and load method changes beforehand.</p>"},{"location":"tg/xilinx/","title":"Xilinx FGPAs","text":"<p>This page describes how to map Cheshire on Xilinx FPGAs to execute baremetal programs or boot CVA6 Linux. Please first read Getting Started to make sure have all dependencies and built the hardware, software, and Xilinx FPGA scripts. Additionally, for on-chip debugging you need:</p> <ul> <li>OpenOCD <code>&gt;= 0.10.0</code></li> </ul> <p>We currently provide working setups for:</p> <ul> <li>Digilent Genesys 2 with Vivado <code>&gt;= 2020.2</code></li> </ul> <p>We are working on support for more boards in the future.</p>"},{"location":"tg/xilinx/#implementation","title":"Implementation","text":"<p>Since the implementation steps and available features vary between boards, we provide instructions and document available features for each.</p>"},{"location":"tg/xilinx/#digilent-genesys-2","title":"Digilent Genesys 2","text":"<p>Generate the bitstream <code>target/xilinx/out/cheshire_top_xilinx.bit</code> by running:</p> <pre><code>make -C target/xilinx\n</code></pre> <p>Before flashing the bitstream to your device, take note of the position of onboard switches, which control important functionality:</p> Switch Function 1 .. 0 Boot mode; see Boot ROM 5 .. 2 Fan level; do not keep at 0 7 Test mode; leave at zero <p>The reset, JTAG TAP, UART, I2C, and VGA are all connected to their onboard logic or ports. The UART has no flow control. The microSD slot is connected to chip select 0 of the SPI host peripheral. Serial link and GPIOs are currently not available.</p>"},{"location":"tg/xilinx/#debugging-with-openocd","title":"Debugging with OpenOCD","text":"<p>To establish a debug bridge over JTAG, ensure the target is in a debuggable state (for example by resetting into the idle boot mode 0) and launch OpenOCD with:</p> <pre><code>openocd -f $(bender path ariane)/corev_apu/fpga/ariane.cfg\n</code></pre> <p>In another shell, launch a RISC-V GDB session attaching to OpenOCD:</p> <pre><code>riscv64-unknown-elf-gdb -ex \"target extended-remote localhost:3333\"\n</code></pre> <p>You can now interrupt (Ctrl+C), inspect, and repoint execution with GDB as usual. Note that resetting the board during debug sessions is not supported. If the debug session dies or you need to reset the board for another reason:</p> <ol> <li>Terminate GDB and OpenOCD</li> <li>Reset the board</li> <li>Relaunch OpenOCD, then GDB.</li> </ol>"},{"location":"tg/xilinx/#running-baremetal-code","title":"Running Baremetal Code","text":"<p>Baremetal code can be preloaded through JTAG using OpenOCD and GDB or loaded from an SD Card. In principle, other interfaces may also be used to boot if the board provides them, but no setups are available for this.</p> <p>First, connect to UART using a serial communication program like minicom:</p> <pre><code>minicom -cD /dev/ttyUSBX\n</code></pre> <p>Make sure that hardware flow control matches your board's setup (usually off).</p> <p>In the following examples, we will use the <code>helloworld</code> test. As in simulation, you can replace this with any baremetal program of your choosing or design; see Baremetal Programs.</p>"},{"location":"tg/xilinx/#jtag-preloading","title":"JTAG Preloading","text":"<p>Start a debug session in the project root and enter in GDB:</p> <pre><code>load sw/tests/helloworld.spm.elf\ncontinue\n</code></pre> <p>You should see <code>Hello World!</code> output printed on the UART.</p>"},{"location":"tg/xilinx/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>First, build an up-to-date a disk image for your desired binary. For <code>helloworld</code>:</p> <pre><code>make sw/tests/helloworld.gpt.bin\n</code></pre> <p>Then flash this image to an SD card (note that this requires root privileges):</p> <pre><code>sudo dd if=sw/tests/helloworld.gpt.bin of=/dev/&lt;sdcard&gt;\nsudo sgdisk -e /dev/&lt;sdcard&gt;\n</code></pre> <p>The second command only ensures correctness of the partition layout; it moves the secondary GPT header at the end of the minimally sized image to the end of your actual SD card.</p> <p>Insert your SD card and reset into boot mode 1. You should see a <code>Hello World!</code> UART output.</p>"},{"location":"tg/xilinx/#booting-linux","title":"Booting Linux","text":"<p>To boot Linux, we must load the OpenSBI firmware, which takes over M mode and launches the U-boot bootloader. U-boot then loads Linux. For more details, see Boot Flow.</p> <p>Clone the <code>cheshire</code> branch of CVA6 SDK and build the firmware (OpenSBI + U-boot) and Linux images (this will take about 30 minutes):</p> <pre><code>git submodule update --init --recursive sw/deps/cva6-sdk\nmake -C sw/deps/cva6-sdk images\n</code></pre> <p>In principle, we can boot Linux through JTAG by loading all images into memory, launching OpenSBI, and instructing U-boot to load the kernel directly from memory. Here, we focus on autonomous boot from SD card.</p> <p>In this case, OpenSBI is loaded by a regular baremetal program called the Zero-Stage Loader (ZSL). The boot ROM loads the ZSL from SD card, which then loads the device tree and firmware from other SD card partitions into memory and launches OpenSBI.</p> <p>To create a full Linux disk image from the ZSL, device tree, firmware, and Linux, run:</p> <pre><code>make sw/boot/linux.gpt.bin\n</code></pre> <p>Flash this image to an SD card as you did in the previous section, then insert the SD card and reset into boot mode 1. You should first see the ZSL print on the UART:</p> <pre><code> /\\___/\\       Boot mode:       1\n( o   o )      Real-time clock: ... Hz\n(  =^=  )      System clock:    ... Hz\n(        )     Read global ptr: 0x...\n(    P    )    Read pointer:    0x...\n(  U # L   )   Read argument:   0x...\n(    P      )\n(           ))))))))))\n</code></pre> <p>You should then boot through OpenSBI, U-Boot, and Linux until you are dropped into a shell.</p>"},{"location":"um/","title":"User Manual","text":"<p>The user manual provides detailed reference information on Cheshire:</p> <ul> <li>Architecture: Describes the hardware design, features, and configuration of Cheshire.</li> <li>Software Stack: Describes how to run code on Cheshire and its Linux boot flow.</li> </ul>"},{"location":"um/arch/","title":"Architecture","text":"<p>Cheshire is highly configurable; available features and resources depend on its parameterization. The above block diagram depicts a fully-featured Cheshire SoC, which currently provides:</p> <ul> <li> <p>Cores:</p> <ul> <li>Up to 31 Linux-capable CVA6 cores with self-invalidation-based coherence</li> <li>A RISC-V debug module with JTAG transport</li> </ul> </li> <li> <p>Peripherals:</p> <ul> <li>Various standard IO interfaces (UART, I2C, SPI, and GPIOs)</li> <li>A boot ROM enabling boot from SD cards, SPI flash, or I2C EEPROM</li> <li>A VGA display controller with built-in DMA</li> <li>A fully-digital chip-to-chip or die-to-die serial link</li> <li>A high-throughput system DMA</li> </ul> </li> <li> <p>Interconnect:</p> <ul> <li>A last level cache (LLC) configurable as a scratchpad memory (SPM) per-way</li> <li>Up to 16 external AXI4 manager ports and 16 AXI and Regbus subordinate ports</li> <li>Per-manager AXI4 traffic regulators for real-time applications</li> <li>Per-manager AXI4 bus error units (UNBENT) for interconnect error handling</li> </ul> </li> <li> <p>Interrupts:</p> <ul> <li>Core-local (CLINT and CLIC) and platform (PLIC) interrupt controllers</li> <li>Dynamic interrupt routing from and to internal and external targets.</li> </ul> </li> </ul>"},{"location":"um/arch/#memory-map","title":"Memory Map","text":"<p>Cheshire's internal memory map is static. While device instantiation and layout may vary, each device is provided an address space of fixed location and size. For this, Cheshire reserves the address space from <code>0x0</code> to <code>0x2000_0000</code>, which is currently allocated as follows:</p> <p>Block</p> <p>Device</p> <p>Start</p> <p>Size</p> <p>Flags</p> <p>256K periphs @ AXI</p> <p>Debug ROM</p> <p><code>0x0000_0000</code></p> <p>256K</p> <p>E</p> <p>4K periphs @ AXI</p> <p>AXI DMA (Cfg)</p> <p><code>0x0100_0000</code></p> <p>4K</p> <p>256K periphs @ Reg</p> <p>Boot ROM</p> <p><code>0x0200_0000</code></p> <p>256K</p> <p>E</p> <p>CLINT</p> <p><code>0x0204_0000</code></p> <p>256K</p> <p>IRQ router</p> <p><code>0x0208_0000</code></p> <p>256K</p> <p>AXI RT (Cfg)</p> <p><code>0x020C_0000</code></p> <p>256K</p> <p>4K periphs @ Reg</p> <p>SoC Regs</p> <p><code>0x0300_0000</code></p> <p>4K</p> <p>LLC (Cfg)</p> <p><code>0x0300_1000</code></p> <p>4K</p> <p>UART</p> <p><code>0x0300_2000</code></p> <p>4K</p> <p>I2C</p> <p><code>0x0300_3000</code></p> <p>4K</p> <p>SPI Host</p> <p><code>0x0300_4000</code></p> <p>4K</p> <p>GPIO</p> <p><code>0x0300_5000</code></p> <p>4K</p> <p>Serial Link (Cfg)</p> <p><code>0x0300_6000</code></p> <p>4K</p> <p>VGA (Cfg)</p> <p><code>0x0300_7000</code></p> <p>4K</p> <p>UNBENT</p> <p><code>0x0300_8000</code></p> <p>4K</p> <p>INTCs @ Reg</p> <p>PLIC</p> <p><code>0x0400_0000</code></p> <p>64M</p> <p>CLICs</p> <p><code>0x0800_0000</code></p> <p>64M</p> <p>LLC SPM @ AXI</p> <p>cached</p> <p><code>0x1000_0000</code></p> <p>64M</p> <p>CIE</p> <p>uncached</p> <p><code>0x1400_0000</code></p> <p>64M</p> <p>IE</p> <p>The flags are defined as follows:</p> <ul> <li>Cacheable: Accessed data may be cached in the L1 or LLC caches</li> <li>Idempotent: Multiple identical or composing accesses are equivalent to one access</li> <li>Executable: Data in this region may be executed.</li> </ul> <p>Additionally, Cheshire assumes the following parameterized layout for external resources:</p> Block Start End Flags External on-chip <code>0x2000_0000</code> <code>0x8000_0000</code> (Param.) LLC out (DRAM) <code>LlcOutRegionStart</code> <code>LlcOutRegionEnd</code> CIE Serial Link <code>SlinkRegionStart</code> <code>SlinkRegionEnd</code> <p>The external on-chip region is split into one subregion with full <code>CIE</code> flags and one without flags to minimize parameterization complexity. The <code>Cva6ExtCieOnTop</code> and <code>Cva6ExtCieLength</code> parameters control the order and partitioning of these two regions, respectively.</p> <p>The LLC out region must not collide with any other regions and defaults on starting at the lowest available address, <code>0x8000_0000</code>. The Serial Link region defaults on starting at <code>0x1_0000_0000</code>, configuring the <code>SlinkTxAddrMask</code> and <code>SlinkTxAddrDomain</code> parameters to mirror the lower 32-bit space of another identical chip from this address base.</p>"},{"location":"um/arch/#components-and-parameters","title":"Components and Parameters","text":"<p>Except for external hart debug info and interface types (see Instantiating Cheshire), Cheshire is fully parameterized through its <code>Cfg</code> struct parameter. We will first describe global parameters, then discuss the functionality and parameterization of each component individually.</p> <p>For defaults of any parameters, <code>cheshire_pkg::DefaultCfg</code> is the single source of truth. Note, however, that this does not mean <code>DefaultCfg</code> parameters are suitable for your system or usecase; please carefully consider and choose all parameters in your instantiation.</p> <p>The following global parameters control basic functionality and features and can be read by software in the SoC Registers:</p> Parameter Type / Range Description <code>RtcFreq</code> <code>word_bt</code> Frequency (Hz) configured for real-time clock <code>PlatformRom</code> <code>word_bt</code> Address of platform ROM; see Boot ROM <code>Bootrom</code> <code>bit</code> Whether boot ROM is available <code>Uart</code> <code>bit</code> Whether UART is available <code>I2c</code> <code>bit</code> Whether I2C host is available <code>SpiHost</code> <code>bit</code> Whether SPI is available <code>Gpio</code> <code>bit</code> Whether GPIO is available <code>Dma</code> <code>bit</code> Whether DMA is available <code>SerialLink</code> <code>bit</code> Whether serial link is available <code>Vga</code> <code>bit</code> Whether VGA is available <code>AxiRt</code> <code>bit</code> Whether AXI RT is available <code>Clic</code> <code>bit</code> Whether CLIC is available <code>IrqRouter</code> <code>bit</code> Whether IRQ Router is available <code>BusErr</code> <code>bit</code> Whether UNBENT (bus error unit) is available"},{"location":"um/arch/#cva6-cores","title":"CVA6 Cores","text":"<p>Cheshire defaults on using CVA6 with hypervisor and CLIC support enabled; RV32 configurations are not supported. Most parameters for the CVA6 cores are derived from Cheshire's configuration or immutable. The available core parameters are listed below:</p> Parameter Type / Range Description <code>NumCores</code> <code>1..31</code> Number of instantiated CVA6 cores <code>Cva6RASDepth</code> <code>shrt_bt</code> Depth of CVA6 return address stack (RAS) <code>Cva6(BTB|BHT|NrPMP)Entries</code> <code>shrt_bt</code> Number of BTB, BHT, and PMP entries in CVA6 <code>Cva6ExtCieLength</code> <code>doub_bt</code> CIE subregion length in external on-chip region <code>Cva6ExtCieOnTop</code> <code>bit</code> Whether CIE subregion is on top or bottom <code>CoreMaxTxns</code> <code>dw_bt</code> Maximum total AXI4 transactions per core <code>CoreMaxTxnsPerId</code> <code>dw_bt</code> Maximum total AXI4 transactions per core and ID <code>CoreUserAmoOffs</code> <code>doub_bt</code> Base offset for core IDs within user AMO range <p>Each CVA6 core is a standalone AXI4 manager at the crossbar. Coherence is maintained through a self-invalidation scheme and RISC-V atomics are handled through a custom, user-channel-based AXI4 extension. For the latter, we wrap the cores and other managers to give each a default user channel assignment and, for atomics-capable managers, a unique ID on a slice of user bits.</p>"},{"location":"um/arch/#interconnect","title":"Interconnect","text":"<p>The interconnect is composed of a main AXI4 crossbar with AXI5 atomic operations (ATOPs) support and an auxiliary Regbus demultiplexer providing access to numerous peripherals and configuration interfaces. The Regbus has a static data width of 32 bit.</p> <p>As the Regbus protocol is not capable of bursts, parallel read and writes, or pipelining, it is much less performant than AXI4, but also much cheaper to implement. Thus, our approach of hierarchically combining AXI4 and Regbus significantly improves interconnect scaling.</p> <p>The internal interconnect exposes the following parameters:</p> Parameter Type / Range Description <code>AddrWidth</code> <code>32..64</code> AXI4 and Regbus address width <code>Axi(Data|User|MstId)Width</code> <code>shrt_bt</code> AXI4 data, user, and manager ID width <code>AxiMax(Mst|Slv)Trans</code> <code>shrt_bt</code> AXI4 maximum inflight transactions at crossbar <code>AxiUserDefault</code> <code>doub_bt</code> AXI4 default user value amended by user features <code>AxiUserAmo(Msb|Lsb)</code> <code>dw_bt</code> AXI4 user channel bit-range used by RISC-V AMOs <code>AxiUserErr(Bits|Lsb)</code> <code>dw_bt</code> AXI4 user channel bit-range for custom errors <code>RegMax(Read|Write)Txns</code> <code>dw_bt</code> Max. inflight transactions at Regbus AMO filter <code>RegAmoNumCuts</code> <code>aw_bt</code> Number of timing cuts inside Regbus AMO filter <code>RegAmoPostCut</code> <code>bit</code> Whether to insert a cut after Regbus AMO filter <code>(Axi|Reg)ExtNum(Mst|Slv)</code> <code>0..15</code> AXI4 and Regbus number of external Mgrs. or Subs. <code>(Axi|Reg)ExtNumRules</code> <code>0..15</code> AXI4 and Regbus number of external address rules <code>(Axi|Reg)ExtRegion*</code> <code>doub_bt</code> AXI4 and Regbus external address regions <code>AxiRt*</code> <code>word_bt</code> AXI4 real-time traffic regulation parameters <p>Both the AXI4 and Regbus interconnects support exposing a limited number of external manager and subordinate ports; this is the intended mechanism through which Cheshire can be integrated with wrapping SoCs' memory systems.</p> <p>The parameter <code>AxiUserDefault</code> defines the default AXI4 user signal assignment. <code>AxiUserAmo(Msb|Lsb)</code> and <code>AxiUserErr(Bits|Lsb)</code> define which bits of the user signals identify RISC-V atomics managers and communicate custom errors, respectively.</p> <p>The AXI4 interconnect has two optional features. <code>AxiRt</code> adds traffic regulation units to each AXI4 manager to provide bandwidth and traffic control for real-time applications. <code>BusErr</code> adds the UNBENT bus error reporter to all managers spawning requests and imprecisely reports AXI4 error responses through a Regbus-mapped interface.</p>"},{"location":"um/arch/#interrupts","title":"Interrupts","text":"<p>Cheshire provides a flexible RISC-V interrupt architecture that can route and multiplex internal and external interrupts to both internal and external controllers and targets. For simplicity, the internal interrupt map is static (non-existent interrupts being tied to 0), while the external interrupt map depends on the surrounding system. Interrupts expose the following parameters:</p> Parameter Type / Range Description <code>NumExtInIntrs</code> <code>doub_bt</code> Total number of external interrupt sources <code>NumExtClicIntrs</code> <code>shrt_bt</code> Number of external interrupt sources allocated in CLIC <code>ClicIntCtlBits</code> <code>shrt_bt</code> Number of interrupt control bits in CLIC <code>NumExtOutIntrTgts</code> <code>byte_bt</code> Number of external interrupt targets <code>NumExtOutIntrs</code> <code>shrt_bt</code> Number of sources for external interrupt targets <code>NumExtIrqHarts</code> <code>doub_bt</code> Number of external interruptible harts <p>First, all internal (<code>intr.intn</code>) and external (<code>intr_ext_i</code>) interrupt sources are collected (<code>intr</code>). From here, they either pass through an interrupt router if enabled (<code>IrqRouter</code>) or are simply fanned out to interrupt targets, which may support as many or fewer interrupt sources as provided by <code>intr</code>. If a target supports fewer sources, its interrupt sources are truncated.</p> <p>Cheshire provides both a core-local interruptor (CLINT), grouping all per-core interrupts in one module, and a shared platform-level interrupt controller (PLIC). The former is used only for inter-processor and timer interrupts, while the latter is a proper interrupt target. If enabled (<code>Clic</code>), each CVA6 core also has a core-local interrupt controller (CLIC), another interrupt target. In addition to the PLIC and CLICs, any number external interrupt targets may be defined (<code>NumExtOutIntrTgts</code>) with their own number of incoming sources (<code>NumExtIrqHarts</code>).</p> <p>Finally, the PLIC and grouped CLINT also support allocating external harts for which to manage interrupts (<code>NumExtIrqHarts</code>), i.e. harts without interrupt controllers of themselves.</p>"},{"location":"um/arch/#debug-module","title":"Debug Module","text":"<p>Cheshire provides a RISC-V-compliant Debug Module with JTAG transport. It supports debugging both internal and external harts as well as system bus access (SBA). It exposes the following parameters:</p> Parameter Type / Range Description <code>DbgIdCode</code> <code>word_bt</code> JTAG ID code reported by Debug module <code>DbgMaxReqs</code> <code>dw_bt</code> Maximum outstanding requests to manager port <code>DbgMax(Read|Write)Txns</code> <code>dw_bt</code> Maximum ourstanding requests to subordinate port <code>DbgAmoNumCuts</code> <code>aw_bt</code> Number of timing cuts inside Debug AMO filter <code>DbgAmoPostCut</code> <code>bit</code> Whether to insert a cut after Debug AMO filter"},{"location":"um/arch/#last-level-cache","title":"Last Level Cache","text":"<p>The Last Level Cache (LLC) sits between Cheshire and its main memory (usually DRAM). It is assumed to be the only manager accessing this memory and caches all accesses to it unless explicitly bypassed through AXI cache control signals. It exposes the following parameters:</p> Parameter Type / Range Description <code>LlcOutConnect</code> <code>bit</code> Whether to create a manager port for the LLC <code>LlcNotBypass</code> <code>bit</code> Whether to instantiate the LLC or create a bypass <code>LlcOutRegion(Start|End)</code> <code>doub_bt</code> Mapped region of outgoing LLC manager port (DRAM) <code>LlcSetAssoc</code> <code>shrt_bt</code> Number of sets in LLC <code>LlcNum(Lines|Blocks)</code> <code>shrt_bt</code> Number of lines and blocks for LLC <code>LlcMax(Read|Write)Txns</code> <code>dw_bt</code> Max. number of outstanding requests to LLC <code>LlcAmoNumCuts</code> <code>aw_bt</code> Number of timing cuts inside manager AMO filter <code>LlcAmoPostCut</code> <code>bit</code> Whether to insert a cut after manager AMO filter <p>Each way of the LLC can individually be switched between caching and acting as a scratchpad memory (SPM). On initial boot, all ways are configured as SPM and the LLC does not cache any accesses; the SPM is used as a working memory for the boot ROM to enable autonomous bootstrapping from external memory.</p> <p>The LLC may be entirely omitted through <code>LlcNotBypass</code>, for example if a more elaborate external main memory system is used. In this case, an external substitute scratchpad memory is required iff Cheshire should boot and run bare-metal code from scratchpad memory as usual. If the LLC is omitted, its port remains iff <code>LlcOutConnect</code> is set, providing a manager port with a RISC-V atomics filter and the above parameters only.</p>"},{"location":"um/arch/#vga-controller","title":"VGA Controller","text":"<p>The VGA Controller enables the drawing of video frames in memory over a VGA interface. It autonomously fetches frame data using an AXI manager port. Note that it currently only supports whole-byte pixel formats. It exposes the following parameters:</p> Parameter Type / Range Description <code>Vga(Red|Green|Blue)Width</code> <code>byte_bt</code> Bit width of red, green, and blue output channels <code>Vga(H|V)CountWidth</code> <code>aw_bt</code> Horizontal and vertical sync counter width"},{"location":"um/arch/#serial-link","title":"Serial Link","text":"<p>The Serial Link is a fully digital, double-data-rate (DDR) chip-to-chip or die-to-die interface serializing AXI4. It can be used to communicate with other SoCs using it, such as other Cheshire instances or FPGAs providing further peripheral or accelerator functionality. It exposes the following parameters:</p> Parameter Type / Range Description <code>SlinkMaxClkDiv</code> <code>shrt_bt</code> Max. system clock divider for DDR interface <code>SlinkMaxTxnsPerId</code> <code>dw_bt</code> Max. number of inflight outgoing requests per ID <code>SlinkMaxUniqIds</code> <code>dw_bt</code> Max. number of inflight IDs for outgoing requests <code>SlinkRegion(Start|End)</code> <code>doub_bt</code> Address range for outgoing requests <code>SlinkTxAddrMask</code> <code>doub_bt</code> Address mask to apply on incoming requests <code>SlinkTxAddrDomain</code> <code>doub_bt</code> Address domain to cast incoming requests into <code>SlinkUserAmoBit</code> <code>dw_bt</code> AXI4 AMO user bit to set on incoming requests"},{"location":"um/arch/#dma-engine","title":"DMA engine","text":"<p>The iDMA engine enables high-throughput asynchronous transfers between any two subordinate address ranges in the system. The hardware supports, if enabled, up to two-dimensional transfers directly in hardware. It exposes the following parameters:</p> Parameter Type / Range Description <code>DmaConfMax(Read|Write)Txns</code> <code>dw_bt</code> Max. number of outstanding requests to DMA config <code>DmaConfAmoNumCuts</code> <code>aw_bt</code> Number of timing cuts inside config AMO filter <code>DmaConfAmoPostCut</code> <code>bit</code> Whether to insert a cut after config AMO filter <code>DmaConfEnableTwoD</code> <code>bit</code> Whether the 2D hardware extension is present <code>DmaNumAxInFlight</code> <code>dw_bt</code> Number of outstanding transfers the DMA launches <code>DmaMemSysDepth</code> <code>dw_bt</code> The approximate depth of the memory system <code>DmaJobFifoDepth</code> <code>aw_bt</code> The depth of the job FIFO <code>DmaRAWCouplingAvail</code> <code>bit</code> Whether the R-AW coupling feature is available"},{"location":"um/arch/#i2c-spi-gpios","title":"I2C, SPI, GPIOs","text":"<p>The I2C host, SPI host, and GPIO interface are IPs provided by OpenTitan and adapted for use in PULP systems. They remain compatible with and use OpenTitan's device interface functions (DIFs) with minor patches. For more information on these peripherals, please consult the OpenTitan IP Block Documentation. These peripherals expose the following parameters:</p> Parameter Type / Range Description <code>GpioInputSyncs</code> <code>bit</code> Whether to add two-FF synchronizers to GPIO inputs"},{"location":"um/arch/#uart","title":"UART","text":"<p>Cheshire's UART is compatible with the TI 16750. Thus, it is compatible with OpenSBI, U-Boot, and Linux out of the box. Note that Cheshire exposes the interface's modem access control for systems that wish to use it; if you do not, be sure to correctly tie off these signals.</p>"},{"location":"um/arch/#boot-rom","title":"Boot ROM","text":"<p>The boot ROM contains the first code executed by Cheshire's internal cores after reset. It serves to load a mutable program from an external source in a safe, swift, and verifiable fashion. It deserves particular attention because when implemented in unchangeable hardware, boot ROM bugs may seriously impact or altogether destroy the functionality of silicon implementations. For more information on Cheshire's built-in boot ROM, see the Boot ROM section in the Software Stack chapter.</p> <p>The boot ROM can optionally invoke a Platform ROM before code loading to set up essential features of the surrounding system; this is done iff the platform ROM address parameter (<code>PlatformRom</code>) is nonzero. If the boot ROM is not instantiated (<code>BootRom</code>), the internal cores will attempt to boot directly from the configured Platform ROM instead.</p>"},{"location":"um/sw/","title":"Software Stack","text":"<p>Cheshire's software stack currently provides:</p> <ul> <li>A baremetal programming environment and hardware abstraction layer.</li> <li>A zero-stage bootloader (ZSL) and Linux boot chain.</li> <li>A CVA6 Linux with additional drivers and patches.</li> </ul>"},{"location":"um/sw/#baremetal-programs","title":"Baremetal programs","text":"<p>Baremetal programs (BMPs) may be preloaded and invoked either by the boot ROM (see Boot Flow) or through the RISC-V Debug Module interfaced through JTAG. They run directly in M mode. With the provided setup, BMPs can be linked to execute either from the internal scratchpad memory (SPM) or from DRAM.</p> <p>The toolchain in <code>sw</code> can be used to build custom BMPs; the programs in <code>sw/tests</code> and <code>sw/boot</code> may serve as references. BMPs are linked against <code>libcheshire</code> (<code>sw/lib</code> and <code>sw/include</code>), which provides a hardware abstraction layer (HAL) and a minimal C runtime.</p> <p>The C runtime calls <code>int main(void)</code> and forwards traps to the weakly-defined handler <code>void trap_vector(void)</code>, which may be left undefined if trap handling is not needed.</p> <p>On program termination, bit 0 of scratch register 2 (<code>scratch[2][0]</code>) is set to 1 and the return value of <code>main()</code> is written to <code>scratch[2][31:1]</code>. Furthermore, when preloading through UART, the return value is sent out by the UART debug server (see Passive Preload). In simulation, the testbench catches the return value and terminates the simulator, whose exit code will be nonzero iff the return value is.</p> <p>To build a baremetal program (here <code>sw/tests/helloworld.c</code>) executing from the SPM, run:</p> <pre><code>make sw/tests/helloworld.spm.elf\n</code></pre> <p>To create the same program executing from DRAM, <code>sw/tests/helloworld.spm.dram</code> can instead be built from the same source. Depending on their assumptions and behavior, not all programs may be built to execute from both locations.</p>"},{"location":"um/sw/#boot-flow","title":"Boot Flow","text":"<p>On reset, Cheshire immediately starts execution and initializes a minimal C execution environment for the boot ROM by:</p> <ol> <li>Resetting all integer registers (the FPU is disabled).</li> <li>Pausing all nonzero harts.</li> <li>Completing the LLC's self test (if present) and switching it to SPM.</li> <li>Invoking the Platform ROM (if present).</li> </ol>"},{"location":"um/sw/#boot-rom","title":"Boot ROM","text":"<p>The boot ROM is implemented in hardware and therefore immutable. To guarantee verifiability and prevent silicon bricks, it provides only a handful redundant boot modes loading just enough code to run another mutable program or loader. It aims to do this in minimal time and without accessing unnecessary interfaces.</p> <p>The boot ROM supports four builtin boot modes chosen from by the <code>boot_mode_i</code> pins:</p> <code>boot_mode_i[1:0]</code> Boot Medium Interface Used <code>0b00</code> Passive Preload JTAG, Serial Link, or UART <code>0b01</code> SD Card SPI <code>0b10</code> NOR Flash (S25FS512S) SPI <code>0b10</code> EEPROM (24FC1025) I2C"},{"location":"um/sw/#passive-preload","title":"Passive Preload","text":"<p>The passive preload boot mode expects code to be preloaded to an executable location and an entry point to be written to <code>scratch[1:0]</code>. After preloading, execution is launched when <code>scratch[2][0]</code> is set to 1. Unlike for autonomous boot modes, BMPs can directly be preloaded into DRAM and have no size restriction.</p> <p>The JTAG and serial link interfaces can preload programs by directly accessing the memory system. Preloading through UART is special, as UART by itself does not provide a memory access protocol. On receiving an <code>ACK</code> (<code>0x06</code>) byte over UART, the boot ROM launches a debug server that waits for and handles the following commands:</p> TX Opcode TX Arguments Command Sequence <code>0x11</code> (Read) 64b address, 64b length RX <code>ACK</code>, RX read data, RX <code>EOT</code> <code>0x12</code> (Write) 64b address, 64b length RX <code>ACK</code>, TX write data, RX <code>EOT</code> <code>0x13</code> (Exec) 64b address RX <code>ACK</code>, execution, RX <code>ACK</code>, RX return"},{"location":"um/sw/#autonomous-boot","title":"Autonomous Boot","text":"<p>The autonomous boot modes load a BMP of at most 48 KiB from their boot medium into SPM, then execute it. The boot medium can either be GPT-formatted or contain raw code. If no GPT header is found, raw code execution starts from sector 0 of the boot medium.</p> <p>If the boot medium is GPT-formatted, the boot ROM will search for and preload the first partition under 48 KiB in size that is formatted as a Cheshire zero-stage loader (see Partition GUIDs). If no such partition is found, the boot ROM will fall back to booting from the beginning of the boot medium's first partition.</p> <p>BMPs that run from SPM and fit into the alotted size can be compiled into raw images (ROMs) or GPT disk images as follows:</p> <pre><code>make sw/tests/helloworld.(rom|gpt).(bin|memh)\n</code></pre> <p>The boot ROM is not reentrant; when an invoked BMP returns, the system will halt and not reboot.</p>"},{"location":"um/sw/#zero-stage-loader","title":"Zero-Stage Loader","text":"<p>The zero-stage loader (ZSL) is a simple BMP running from SPM that is responsible for chain-loading the OpenSBI firmware, which will take over and manage M mode. The OpenSBI image bundles the U-Boot bootlader as its payload, which will chain-load and invoke Linux.</p> <p>Unlike the boot ROM, the ZSL is fully mutable. Thus, there is no danger to preloading large amounts of data, printing large messages, or accessing DRAM, as any potential bugs cannot brick silicon. The ZSL:</p> <ol> <li>Prints a first UART output listing essential boot parameters.</li> <li>Loads the device tree from the boot medium into DRAM, reusing boot ROM drivers.</li> <li>Loads the firmware from the boot medium into DRAM, reusing boot ROM drivers.</li> <li>Invokes the firmware, passing the device tree as an argument.</li> </ol> <p>Note that when using preloading boot modes, steps 2 and 3 are skipped as the device tree and firmware are assumed to also be preloaded. If the ZSL is autonomously booted, both are loaded from the first partitions of corresponding type on the boot medium (see Partition GUIDs).</p>"},{"location":"um/sw/#firmware","title":"Firmware","text":"<p>OpenSBI takes over M mode and invokes the bundled U-Boot bootloader. U-Boot's behavior is defined by the passed device tree and its default boot command (both target-dependent), but can also dynamically be changed through its command line.</p> <p>Both OpenSBI and U-Boot, provided through a fork of the CVA6 SDK, are largely unchanged from their upstream code bases. U-Boot is patched with a driver for Cheshire's SPI host. Non-SPI loading is currently not implemented, but can be added. Alternatively, the ZSL can be modified to directly load the Linux image to invoke into DRAM.</p>"},{"location":"um/sw/#partition-guids","title":"Partition GUIDs","text":"<p>For boot purposes, Cheshire defines the following partition type GUIDs:</p> Partition Type Type GUID Zero-Stage Loader <code>0269B26A-FD95-4CE4-98CF-941401412C62</code> Device Tree <code>BA442F61-2AEF-42DE-9233-E4D75D3ACB9D</code> Firmware <code>99EC86DA-3F5B-4B0D-8F4B-C4BACFA5F859</code> <p>In a Linux context, Cheshire adheres to established partition type GUIDs.</p>"},{"location":"um/sw/#linux","title":"Linux","text":"<p>Cheshire runs a slightly modified version of CVA6 Linux from the CVA6 SDK. Currently, it adds drivers for our SPI host to enable persistent disk IO, for example on SD cards. We plan on extending Linux driver support for Cheshire's hardware in the future.</p>"}]}